{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rickygould/Documents/Github/Pug-Website/Downloads/web102_unit7lab-main/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rickygould/Documents/Github/Pug-Website/Downloads/web102_unit7lab-main/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/rickygould/Documents/Github/Pug-Website/Downloads/web102_unit7lab-main/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rickygould/Documents/Github/Pug-Website/Downloads/web102_unit7lab-main/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\n\nvar noop = function noop() {};\n\nvar NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';\n\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n\n    _classCallCheck(this, RealtimeClient);\n\n    var _a;\n\n    this.accessToken = null;\n    this.apiKey = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    /**\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\n     *\n     * @internal\n     */\n\n    this._resolveFetch = function (customFetch) {\n      var _fetch;\n\n      if (customFetch) {\n        _fetch = customFetch;\n      } else if (typeof fetch === 'undefined') {\n        _fetch = function _fetch() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return import('@supabase/node-fetch').then(function (_ref) {\n            var fetch = _ref.default;\n            return fetch.apply(void 0, args);\n          });\n        };\n      } else {\n        _fetch = fetch;\n      }\n\n      return function () {\n        return _fetch.apply(void 0, arguments);\n      };\n    };\n\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n\n    if (options === null || options === void 0 ? void 0 : options.transport) {\n      this.transport = options.transport;\n    } else {\n      this.transport = null;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    var accessToken = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n\n    if (accessToken) {\n      this.accessToken = accessToken;\n      this.apiKey = accessToken;\n    }\n\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this.disconnect();\n\n              _this.connect();\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })), this.reconnectAfterMs);\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n\n\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if (this.conn) {\n        return;\n      }\n\n      if (this.transport) {\n        this.conn = new this.transport(this._endPointURL(), undefined, {\n          headers: this.headers\n        });\n        return;\n      }\n\n      if (NATIVE_WEBSOCKET_AVAILABLE) {\n        this.conn = new WebSocket(this._endPointURL());\n        this.setupConnection();\n        return;\n      }\n\n      this.conn = new WSWebSocketDummy(this._endPointURL(), undefined, {\n        close: function close() {\n          _this2.conn = null;\n        }\n      });\n      import('ws').then(function (_ref3) {\n        var WS = _ref3.default;\n        _this2.conn = new WS(_this2._endPointURL(), undefined, {\n          headers: _this2.headers\n        });\n\n        _this2.setupConnection();\n      });\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n\n\n        if (code) {\n          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n        } else {\n          this.conn.close();\n        }\n\n        this.conn = null; // remove open handles\n\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.reset();\n      }\n    }\n    /**\n     * Returns all created channels\n     */\n\n  }, {\n    key: \"getChannels\",\n    value: function getChannels() {\n      return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n\n  }, {\n    key: \"removeChannel\",\n    value: function () {\n      var _removeChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(channel) {\n        var status;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return channel.unsubscribe();\n\n              case 2:\n                status = _context2.sent;\n\n                if (this.channels.length === 0) {\n                  this.disconnect();\n                }\n\n                return _context2.abrupt(\"return\", status);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function removeChannel(_x) {\n        return _removeChannel.apply(this, arguments);\n      }\n\n      return removeChannel;\n    }()\n    /**\n     * Unsubscribes and removes all channels\n     */\n\n  }, {\n    key: \"removeAllChannels\",\n    value: function () {\n      var _removeAllChannels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var values_1;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return Promise.all(this.channels.map(function (channel) {\n                  return channel.unsubscribe();\n                }));\n\n              case 2:\n                values_1 = _context3.sent;\n                this.disconnect();\n                return _context3.abrupt(\"return\", values_1);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function removeAllChannels() {\n        return _removeAllChannels.apply(this, arguments);\n      }\n\n      return removeAllChannels;\n    }()\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        config: {}\n      };\n      var chan = new RealtimeChannel(\"realtime:\".concat(topic), params, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this3 = this;\n\n      var topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref;\n\n      var callback = function callback() {\n        _this3.encode(data, function (result) {\n          var _a;\n\n          (_a = _this3.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          access_token: token\n        });\n\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"_makeRef\",\n    value: function _makeRef() {\n      var newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"_leaveOpenTopic\",\n    value: function _leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c._isJoined() || c._isJoining());\n      });\n\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c._joinRef() !== channel._joinRef();\n      });\n    }\n    /**\n     * Sets up connection handlers.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"setupConnection\",\n    value: function setupConnection() {\n      var _this4 = this;\n\n      if (this.conn) {\n        this.conn.binaryType = 'arraybuffer';\n\n        this.conn.onopen = function () {\n          return _this4._onConnOpen();\n        };\n\n        this.conn.onerror = function (error) {\n          return _this4._onConnError(error);\n        };\n\n        this.conn.onmessage = function (event) {\n          return _this4._onConnMessage(event);\n        };\n\n        this.conn.onclose = function (event) {\n          return _this4._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"_endPointURL\",\n    value: function _endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /** @internal */\n\n  }, {\n    key: \"_onConnMessage\",\n    value: function _onConnMessage(rawMessage) {\n      var _this5 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref;\n\n        if (ref && ref === _this5.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this5.pendingHeartbeatRef = null;\n        }\n\n        _this5.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n\n        _this5.channels.filter(function (channel) {\n          return channel._isMember(topic);\n        }).forEach(function (channel) {\n          return channel._trigger(event, payload, ref);\n        });\n\n        _this5.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this6 = this;\n\n      this.log('transport', \"connected to \".concat(this._endPointURL()));\n\n      this._flushSendBuffer();\n\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this6._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n\n      this._triggerChanError();\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n\n      this._triggerChanError();\n\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel._trigger(CHANNEL_EVENTS.error);\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n\n      if (!this.isConnected()) {\n        return;\n      }\n\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n\n      this.pendingHeartbeatRef = this._makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n  }]);\n\n  return RealtimeClient;\n}();\n\nexport { RealtimeClient as default };\n\nvar WSWebSocketDummy = /*#__PURE__*/_createClass(function WSWebSocketDummy(address, _protocols, options) {\n  _classCallCheck(this, WSWebSocketDummy);\n\n  this.binaryType = 'arraybuffer';\n\n  this.onclose = function () {};\n\n  this.onerror = function () {};\n\n  this.onmessage = function () {};\n\n  this.onopen = function () {};\n\n  this.readyState = SOCKET_STATES.connecting;\n\n  this.send = function () {};\n\n  this.url = null;\n  this.url = address;\n  this.close = options.close;\n});","map":{"version":3,"mappings":"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","names":["VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","NATIVE_WEBSOCKET_AVAILABLE","WebSocket","RealtimeClient","endPoint","options","undefined","open","close","error","message","customFetch","_fetch","fetch","args","then","default","websocket","transport","params","headers","Object","timeout","logger","heartbeatIntervalMs","accessToken","_a","apikey","apiKey","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","serializer","bind","reconnectTimer","disconnect","connect","_resolveFetch","conn","_endPointURL","setupConnection","WSWebSocketDummy","WS","code","reason","onclose","heartbeatTimer","clearInterval","reset","channels","channel","unsubscribe","status","length","Promise","all","map","values_1","kind","msg","data","readyState","connecting","Connecting","Open","closing","Closing","Closed","connectionState","topic","config","chan","push","event","ref","result","send","log","isConnected","sendBuffer","token","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","newRef","toString","dupChannel","find","c","_isJoining","filter","_joinRef","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","_onConnClose","_appendParams","assign","vsn","rawMessage","pendingHeartbeatRef","type","_isMember","_trigger","stateChangeCallbacks","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","_makeRef","setAuth","address","_protocols"],"sources":["/Users/rickygould/Documents/Github/Pug-Website/Downloads/web102_unit7lab-main/client/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\nimport type { WebSocket as WSWebSocket } from 'ws'\n\ntype Fetch = typeof fetch\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocketLikeConstructor\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n  log_level?: 'info' | 'debug' | 'warn' | 'error'\n  fetch?: Fetch\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\ninterface WebSocketLikeConstructor {\n  new (\n    address: string | URL,\n    _ignored?: any,\n    options?: { headers: Object | undefined }\n  ): WebSocketLike\n}\n\ntype WebSocketLike = WebSocket | WSWebSocket | WSWebSocketDummy\n\ninterface WebSocketLikeError {\n  error: any\n  message: string\n  type: string\n}\n\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined'\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  apiKey: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: WebSocketLikeConstructor | null\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocketLike | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  fetch: Fetch\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.transport) {\n      this.transport = options.transport\n    } else {\n      this.transport = null\n    }\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const accessToken = options?.params?.apikey\n    if (accessToken) {\n      this.accessToken = accessToken\n      this.apiKey = accessToken\n    }\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n\n    this.fetch = this._resolveFetch(options?.fetch)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    if (this.transport) {\n      this.conn = new this.transport(this._endPointURL(), undefined, {\n        headers: this.headers,\n      })\n      return\n    }\n\n    if (NATIVE_WEBSOCKET_AVAILABLE) {\n      this.conn = new WebSocket(this._endPointURL())\n      this.setupConnection()\n      return\n    }\n\n    this.conn = new WSWebSocketDummy(this._endPointURL(), undefined, {\n      close: () => {\n        this.conn = null\n      },\n    })\n\n    import('ws').then(({ default: WS }) => {\n      this.conn = new WS(this._endPointURL(), undefined, {\n        headers: this.headers,\n      })\n      this.setupConnection()\n    })\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): void {\n    const { topic, event, payload, ref } = data\n    const callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\n   *\n   * @internal\n   */\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\n    let _fetch: Fetch\n    if (customFetch) {\n      _fetch = customFetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = (...args) =>\n        import('@supabase/node-fetch' as any).then(({ default: fetch }) =>\n          fetch(...args)\n        )\n    } else {\n      _fetch = fetch\n    }\n    return (...args) => _fetch(...args)\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Sets up connection handlers.\n   *\n   * @internal\n   */\n  private setupConnection(): void {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error: WebSocketLikeError) =>\n        this._onConnError(error as WebSocketLikeError)\n      this.conn.onmessage = (event: any) => this._onConnMessage(event)\n      this.conn.onclose = (event: any) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: WebSocketLikeError) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n}\n\nclass WSWebSocketDummy {\n  binaryType: string = 'arraybuffer'\n  close: Function\n  onclose: Function = () => {}\n  onerror: Function = () => {}\n  onmessage: Function = () => {}\n  onopen: Function = () => {}\n  readyState: number = SOCKET_STATES.connecting\n  send: Function = () => {}\n  url: string | URL | null = null\n\n  constructor(\n    address: string,\n    _protocols: undefined,\n    options: { close: Function }\n  ) {\n    this.url = address\n    this.close = options.close\n  }\n}\n"]},"metadata":{},"sourceType":"module"}